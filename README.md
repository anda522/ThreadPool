# 基于C++17的简易线程池

> 所学知识参考链接：
>
> C++11 thread， C++11 mutex：https://wyqz.top/p/2668140628.html
>
> C++11 左右值与移动构造函数：http://avdancedu.com/a39d51f9/



- 实现多线程安全的任务队列，线程池使用异步操作，提交(submit)使用与thread相同。
- 内部利用完美转发获取可调用对象的函数签名，lambda与function包装任务，使用RAII管理线程池的生命周期。

# 线程池

> C++ 线程池：https://zhuanlan.zhihu.com/p/376235626

## 1 概念

- 解决线程的创建和销毁问题（代价问题）
- 解决CPU和IO速度不匹配的问题
- 充分利用多核CPU资源，提高并发效率

线程池: 当进行并行的任务作业操作时，线程的建立与销毁的开销是，阻碍性能进步的关键，因此线程池，由此产生。使用多个线程，无限制循环等待队列，进行计算和操作。帮助快速降低和减少性能损耗。

## 2 组成

1. 线程池管理器：初始化和创建线程，启动和停止线程，调配任务；管理线程池
2. 工作线程：线程池中等待并执行分配的任务
3. 任务接口：添加任务的接口，以提供工作线程调度任务的执行。
4. 任务队列：用于存放没有处理的任务，提供一种缓冲机制，同时具有调度功能，高优先级的任务放在队列前面

主要组成：

- 任务队列
- 执行队列
- 管理组件

## 3 工作情况

- 没有任务执行，缓冲队列为空
- 队列中任务数量小于等待线程池中线程任务的数量
- 任务数量大于等待线程池数量，缓冲队列未满
- 任务数量大于线程池数量，缓冲队列已满

# unique_lock

- 在构造函数中加锁，即定义时
- 在析构函数中解锁，判断锁状态，如果已经解锁的话，不操作，未解锁的话解锁

# shared_mutex

C++17共享锁

# std::move

将`左值或右值`转换为右值

# std::future

- future表示一个异步任务结果

Future模式可以理解成：我有一个任务，提交给了Future，Future替我完成这个任务。期间我自己可以去做任何想做的事情。一段时间之后，我就便可以从Future那儿取出结果。

Future里面有个方法 `get()`是个阻塞等待方法。当线程池一次性submit多个任务的时候。只有所有的任务全部完成，我们才能用GET按照任务的提交顺序依次返回结果。

`std::future`提供了一个重要方法就是`.get()`，这将阻塞主线程，直到future就绪。注意：`.get()`方法只能调用一次。

`std::future`不支持拷贝，支持移动构造。c++提供的另一个类`std::shared_future`支持拷贝。

可以通过下面三个方式来获得`std::future`。

- `std::promise`的get_future函数
- `std::packaged_task`的get_future函数
- `std::async` 函数

# 条件变量

> 参考：https://blog.csdn.net/xhtchina/article/details/90572762

## wait

条件变量是需要和一个互斥锁mutex配合使用，调用`wait()`之前应该先获得mutex，当线程调用 wait() 后将被阻塞，当wait陷入休眠是会自动释放mutex。直到另外某个线程调用 notify_one或notify_all唤醒了当前线程。当线程被唤醒时，此时线程是已经自动占有了mutex。

条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：

- 一个线程因等待"条件变量的条件成立"而挂起；
- 另外一个线程使"条件成立"，给出信号，从而唤醒被等待的线程。

为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是`std::mutex`，并且管理这个锁只能是 `std::unique_lock`  RAII模板类。

线程的阻塞是通过成员函数`wait()/wait_for()/wait_until()`函数实现的。

```cpp
void wait(std::unique_lock<std::mutex>& lock);
//Predicate 谓词函数，可以普通函数或者lambda表达式
template<class Predicate>
void wait(std::unique_lock<std::mutex>& lock, Predicate pred);
```

以上的wait函数都在会阻塞时，自动释放锁权限，即调用unique_lock的成员函数`unlock()`，以便其他线程能有机会获得锁。这就是条件变量只能和unique_lock一起使用的原因，否则当前线程一直占有锁，线程被阻塞。

## notify_all/notify_one

- `notify_one`

若任何线程在 `*this` 上等待，则调用 notify_one 会解阻塞(唤醒)等待线程之一。

- `notify_all`

若任何线程在 *this 上等待，则解阻塞（唤醒）全部等待线程。

## 虚假唤醒

> 参考：https://blog.csdn.net/weixin_42108411/article/details/110138238

在正常情况下，wait类型函数返回时要么是因为被唤醒，要么是因为超时才返回，但是在实际中发现，因此操作系统的原因，wait类型在不满足条件时，它也会返回，这就导致了虚假唤醒。

# 完美转发

> 参考：http://c.biancheng.net/view/7868.html

指的是函数模板可以将自己的参数“完美”地转发给内部调用的其它函数。所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。

C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值，（此时的右值引用又被称为“万能引用”）。

通过将函数模板的形参类型设置为 T&&，我们可以很好地解决接收左、右值的问题。

C++11 标准的开发者已经帮我们想好了解决方案，该新标准还引入了一个模板函数 `forword<T>()`

# RAII

> 参考：https://zhuanlan.zhihu.com/p/600337719

**RAII**，全称**资源获取即初始化**，C++语言的一种管理资源、避免泄漏的惯用法

> RAII要求，资源的有效期与持有资源的[对象的生命期](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/w/index.php%3Ftitle%3D%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F%26action%3Dedit%26redlink%3D1)严格绑定，即由对象的[构造函数](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0)完成[资源的分配](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/w/index.php%3Ftitle%3D%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%86%E9%85%8D%26action%3Dedit%26redlink%3D1)（获取），同时由[析构函数](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0)完成资源的释放。在这种要求
>
> 下，只要对象能正确地析构，就不会出现[资源泄漏](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F)问题。

当我们在一个函数内部使用局部变量，当退出了这个局部变量的作用域时，这个变量也就别销毁了；

当这个变量是类对象时，这个时候，就会自动调用这个类的析 构函数，而这一切都是自动发生的，不要程序员显示的去调用完成。RAII就是这样去完成的。

**由于系统的资源不具有自动释放的功能**，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。**当定义的局部变量的生命结束时，它的析构函数就会自动的被调用**，如此，就不用程序员显示的去调用释放资源的操作了。

# 问题

## 1 为什么条件变量要和互斥锁一起使用

在`wait`操作之前，需要进行条件判断，而此条件属于临界资源，需要在访问前加锁，此时为保护临界资源的需要。

当条件不满足时，wait操作将执行两个步骤，并保证两个操作的原子性：

- 将当前线程加入条件信号的等待队列
- 解开作为参数传入的锁，解除对临界资源的锁定

